# Written by Mark Lammers; Animal Ecology, Vrije Universiteit Amsterdam; marklammers6@gmail.com
# (c) 2018. Released under the terms of the GNU General Public License v3.

db.files<-function(database.folder=getwd(), #The folder holding the database files to analyse
                   file.base.name=F, #The file base name by which to subset the folder (set to FALSE for all)
                   exclude=F, #Any or multiple strings by which files can be excluded
                   split='.',
                   return.dates=F,
                   print.output=T,
                   quiet=F, #absolutely no information is printed
                   print.help=F #no help message is printed, overridden by quiet flag
){
  if(!quiet){
    cat(note('Running db.files.R ...\n'))
    if(print.help){
      cat(note('This function expects a name for the folder that holds the database files\n'))
    }
  }
  
  split<-paste(split,collapse='')
  spl<-paste(split)
  spl<-paste('[',split,']',sep='',collapse='')
  
  # Checks before anything can be done
  if(length(database.folder==1)){
    if(dir.exists(database.folder)){
    wd<-database.folder
    if(!quiet){
      cat(note('Analysing',wd,'using these splits',spl,'\n'))
    }
    } else {
      stop('Input working directory does not exist\n')
    }
  } else {
    stop('Input is not a working directory\n')
  }
  
  # Load file names from folder
  files<-list.files(wd)
  if(length(files)==0){
    stop('The folder is empty')
  }
  file.infos<-t(sapply(files, file.info))
  files<-files[!unlist(file.infos[,2])] #exclude directories
  
  #Subset files by file.base.name, if any
  if(file.base.name!=F){
    if(!quiet){
      cat(note('Subsetting files for those having [',file.base.name,'] in the file name\n'))
    }
    files<-files[grep(file.base.name,files,fixed=T)]
  }
  
  #Exclude other files, if any
  if(exclude[1]!=F){
    if(!quiet){
      cat(note('Excluding files containing [',paste(exclude, collapse = ', '),']\n'))
    }
    for(i in exclude){
      files<-files[grep(i,files,fixed = T,invert = T)]
    }
  }
  
  #Store package file name components
  from.package<-c('registry','summary','subjects','fields','values','sources','db','compare-db','newonly','omitted',
                  'removed','missing','masked','found','multicol','nosource','verify','verification','log','backup','staged')
  
  if(length(files)==0){
    file.base.names<-NA
    filetypes<-NA
    package.components<-NA
    dates<-NA
  } else {
    
    #Extract file information using apply functions
    options(warn=-1)
    output<-sapply(files,function(f){
      components<-unlist(strsplit(f, spl))
      datatype<-ifelse(!is.na(as.integer(components)),'integer','character')
      df<-data.frame(components=components)
      df$datatype<-datatype
      df$identity<-NA
      
      # Find dates in file names
      is.date<-df$datatype=='integer' & nchar(df$components)==8
      df$identity[is.date]<-'date'
      
      # Find components generated by the package in file names
      by.package<-df$components %in% from.package
      df$identity[by.package]<-'package'
      
      # Find the file.base.name and extension in file names
      df$identity[is.na(df$identity)]<-'file.base.name'
      df$identity[nrow(df)]<-'filetype' #overwrites "backup is from package"
      
      return(df)
    })
    options(warn=0)
    
    # Store output
    if(length(files)==1){
      output<-as.data.frame(output[,1])
      file.base.names<-output[output[,'identity']=='file.base.name','components']
      filetypes<-output[output[,'identity']=='filetype','components']
      package.components<-output[output[,'identity']=='package','components']
      dates<-output[output[,'identity']=='date','components']
    } else {
      file.base.names<-unique(unname(sapply(mapply(`[`,
                                             output['components',],
                                             lapply(output['identity',],`==`,'file.base.name')),
                                      paste, collapse='.')))
      filetypes<-unique(unname(unlist(mapply(`[`,
                                             output['components',],
                                             lapply(output['identity',],`==`,'filetype')))))
      package.components<-unique(unname(unlist(mapply(`[`,
                                                      output['components',],
                                                      lapply(output['identity',],`==`,'package')))))
      dates<-unique(unname(unlist(mapply(`[`,
                                         output['components',],
                                         lapply(output['identity',],`==`,'date')))))
    }
  }
  
  #Also, for every file.base.name, print when it was last updated
  #TODO
  
  # Print output
  if(print.output){
    cat(note('Folder contains',length(files),'files\n'))
    cat(note('File base names in the folder are:\n'))
    print(file.base.names)
    cat(note('File extensions in the folder are:\n'))
    print(filetypes)
    cat(note('Package-generated files in the folder are:\n'))
    print(package.components)
    cat(note('Dates on which files were saved in the folder by the package are:\n'))
    print(dates)
  }
  
  if(return.dates){
    return(dates)
  }
  
}
